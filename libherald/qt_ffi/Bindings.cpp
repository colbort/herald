/* generated by rust_qt_binding_generator */
#include "Bindings.h"

namespace {

    struct option_qint64 {
    public:
        qint64 value;
        bool some;
        operator QVariant() const {
            if (some) {
                return QVariant::fromValue(value);
            }
            return QVariant();
        }
    };
    static_assert(std::is_pod<option_qint64>::value, "option_qint64 must be a POD type.");

    struct option_quintptr {
    public:
        quintptr value;
        bool some;
        operator QVariant() const {
            if (some) {
                return QVariant::fromValue(value);
            }
            return QVariant();
        }
    };
    static_assert(std::is_pod<option_quintptr>::value, "option_quintptr must be a POD type.");

    typedef void (*qstring_set)(QString* val, const char* utf8, int nbytes);
    void set_qstring(QString* val, const char* utf8, int nbytes) {
        *val = QString::fromUtf8(utf8, nbytes);
    }

    struct qmodelindex_t {
        int row;
        quintptr id;
    };
    inline QVariant cleanNullQVariant(const QVariant& v) {
        return (v.isNull()) ?QVariant() :v;
    }
    inline void configColorChanged(Config* o)
    {
        Q_EMIT o->colorChanged();
    }
    inline void configColorschemeChanged(Config* o)
    {
        Q_EMIT o->colorschemeChanged();
    }
    inline void configConfigIdChanged(Config* o)
    {
        Q_EMIT o->configIdChanged();
    }
    inline void configNameChanged(Config* o)
    {
        Q_EMIT o->nameChanged();
    }
    inline void configProfile_pictureChanged(Config* o)
    {
        Q_EMIT o->profile_pictureChanged();
    }
    inline void messagesConversationIdChanged(Messages* o)
    {
        Q_EMIT o->conversationIdChanged();
    }
    inline void networkHandleConnectionPendingChanged(NetworkHandle* o)
    {
        Q_EMIT o->connectionPendingChanged();
    }
    inline void networkHandleConnectionUpChanged(NetworkHandle* o)
    {
        Q_EMIT o->connectionUpChanged();
    }
    inline void networkHandleNewMessageChanged(NetworkHandle* o)
    {
        Q_EMIT o->newMessageChanged();
    }
}
extern "C" {
    Config::Private* config_new(Config*, void (*)(Config*), void (*)(Config*), void (*)(Config*), void (*)(Config*), void (*)(Config*));
    void config_free(Config::Private*);
    quint32 config_color_get(const Config::Private*);
    void config_color_set(Config::Private*, quint32);
    quint32 config_colorscheme_get(const Config::Private*);
    void config_colorscheme_set(Config::Private*, quint32);
    void config_config_id_get(const Config::Private*, QString*, qstring_set);
    void config_config_id_set(Config::Private*, const ushort *str, int len);
    void config_name_get(const Config::Private*, QString*, qstring_set);
    void config_name_set(Config::Private*, const ushort *str, int len);
    void config_name_set_none(Config::Private*);
    void config_profile_picture_get(const Config::Private*, QString*, qstring_set);
    void config_profile_picture_set(Config::Private*, const ushort *str, int len);
    void config_profile_picture_set_none(Config::Private*);
    bool config_exists(const Config::Private*);
};

extern "C" {
    bool contacts_data_archive_status(const Contacts::Private*, int);
    bool contacts_set_data_archive_status(Contacts::Private*, int, bool);
    quint32 contacts_data_color(const Contacts::Private*, int);
    bool contacts_set_data_color(Contacts::Private*, int, quint32);
    void contacts_data_contact_id(const Contacts::Private*, int, QString*, qstring_set);
    bool contacts_data_matched(const Contacts::Private*, int);
    bool contacts_set_data_matched(Contacts::Private*, int, bool);
    void contacts_data_name(const Contacts::Private*, int, QString*, qstring_set);
    bool contacts_set_data_name(Contacts::Private*, int, const ushort* s, int len);
    bool contacts_set_data_name_none(Contacts::Private*, int);
    void contacts_data_profile_picture(const Contacts::Private*, int, QString*, qstring_set);
    bool contacts_set_data_profile_picture(Contacts::Private*, int, const ushort* s, int len);
    bool contacts_set_data_profile_picture_none(Contacts::Private*, int);
    void contacts_sort(Contacts::Private*, unsigned char column, Qt::SortOrder order = Qt::AscendingOrder);

    int contacts_row_count(const Contacts::Private*);
    bool contacts_insert_rows(Contacts::Private*, int, int);
    bool contacts_remove_rows(Contacts::Private*, int, int);
    bool contacts_can_fetch_more(const Contacts::Private*);
    void contacts_fetch_more(Contacts::Private*);
}
int Contacts::columnCount(const QModelIndex &parent) const
{
    return (parent.isValid()) ? 0 : 1;
}

bool Contacts::hasChildren(const QModelIndex &parent) const
{
    return rowCount(parent) > 0;
}

int Contacts::rowCount(const QModelIndex &parent) const
{
    return (parent.isValid()) ? 0 : contacts_row_count(m_d);
}

bool Contacts::insertRows(int row, int count, const QModelIndex &)
{
    return contacts_insert_rows(m_d, row, count);
}

bool Contacts::removeRows(int row, int count, const QModelIndex &)
{
    return contacts_remove_rows(m_d, row, count);
}

QModelIndex Contacts::index(int row, int column, const QModelIndex &parent) const
{
    if (!parent.isValid() && row >= 0 && row < rowCount(parent) && column >= 0 && column < 1) {
        return createIndex(row, column, (quintptr)row);
    }
    return QModelIndex();
}

QModelIndex Contacts::parent(const QModelIndex &) const
{
    return QModelIndex();
}

bool Contacts::canFetchMore(const QModelIndex &parent) const
{
    return (parent.isValid()) ? 0 : contacts_can_fetch_more(m_d);
}

void Contacts::fetchMore(const QModelIndex &parent)
{
    if (!parent.isValid()) {
        contacts_fetch_more(m_d);
    }
}
void Contacts::updatePersistentIndexes() {}

void Contacts::sort(int column, Qt::SortOrder order)
{
    contacts_sort(m_d, column, order);
}
Qt::ItemFlags Contacts::flags(const QModelIndex &i) const
{
    auto flags = QAbstractItemModel::flags(i);
    if (i.column() == 0) {
        flags |= Qt::ItemIsEditable;
    }
    return flags;
}

bool Contacts::archive_status(int row) const
{
    return contacts_data_archive_status(m_d, row);
}

bool Contacts::setArchive_status(int row, bool value)
{
    bool set = false;
    set = contacts_set_data_archive_status(m_d, row, value);
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        Q_EMIT dataChanged(index, index);
    }
    return set;
}

quint32 Contacts::color(int row) const
{
    return contacts_data_color(m_d, row);
}

bool Contacts::setColor(int row, quint32 value)
{
    bool set = false;
    set = contacts_set_data_color(m_d, row, value);
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        Q_EMIT dataChanged(index, index);
    }
    return set;
}

QString Contacts::contactId(int row) const
{
    QString s;
    contacts_data_contact_id(m_d, row, &s, set_qstring);
    return s;
}

bool Contacts::matched(int row) const
{
    return contacts_data_matched(m_d, row);
}

bool Contacts::setMatched(int row, bool value)
{
    bool set = false;
    set = contacts_set_data_matched(m_d, row, value);
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        Q_EMIT dataChanged(index, index);
    }
    return set;
}

QString Contacts::name(int row) const
{
    QString s;
    contacts_data_name(m_d, row, &s, set_qstring);
    return s;
}

bool Contacts::setName(int row, const QString& value)
{
    bool set = false;
    if (value.isNull()) {
        set = contacts_set_data_name_none(m_d, row);
    } else {
    set = contacts_set_data_name(m_d, row, value.utf16(), value.length());
    }
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        Q_EMIT dataChanged(index, index);
    }
    return set;
}

QString Contacts::profile_picture(int row) const
{
    QString s;
    contacts_data_profile_picture(m_d, row, &s, set_qstring);
    return s;
}

bool Contacts::setProfile_picture(int row, const QString& value)
{
    bool set = false;
    if (value.isNull()) {
        set = contacts_set_data_profile_picture_none(m_d, row);
    } else {
    set = contacts_set_data_profile_picture(m_d, row, value.utf16(), value.length());
    }
    if (set) {
        QModelIndex index = createIndex(row, 0, row);
        Q_EMIT dataChanged(index, index);
    }
    return set;
}

QVariant Contacts::data(const QModelIndex &index, int role) const
{
    Q_ASSERT(rowCount(index.parent()) > index.row());
    switch (index.column()) {
    case 0:
        switch (role) {
        case Qt::UserRole + 0:
            return QVariant::fromValue(archive_status(index.row()));
        case Qt::UserRole + 1:
            return QVariant::fromValue(color(index.row()));
        case Qt::UserRole + 2:
            return QVariant::fromValue(contactId(index.row()));
        case Qt::UserRole + 3:
            return QVariant::fromValue(matched(index.row()));
        case Qt::UserRole + 4:
            return cleanNullQVariant(QVariant::fromValue(name(index.row())));
        case Qt::UserRole + 5:
            return cleanNullQVariant(QVariant::fromValue(profile_picture(index.row())));
        }
        break;
    }
    return QVariant();
}

int Contacts::role(const char* name) const {
    auto names = roleNames();
    auto i = names.constBegin();
    while (i != names.constEnd()) {
        if (i.value() == name) {
            return i.key();
        }
        ++i;
    }
    return -1;
}
QHash<int, QByteArray> Contacts::roleNames() const {
    QHash<int, QByteArray> names = QAbstractItemModel::roleNames();
    names.insert(Qt::UserRole + 0, "archive_status");
    names.insert(Qt::UserRole + 1, "color");
    names.insert(Qt::UserRole + 2, "contactId");
    names.insert(Qt::UserRole + 3, "matched");
    names.insert(Qt::UserRole + 4, "name");
    names.insert(Qt::UserRole + 5, "profile_picture");
    return names;
}
QVariant Contacts::headerData(int section, Qt::Orientation orientation, int role) const
{
    if (orientation != Qt::Horizontal) {
        return QVariant();
    }
    return m_headerData.value(qMakePair(section, (Qt::ItemDataRole)role), role == Qt::DisplayRole ?QString::number(section + 1) :QVariant());
}

bool Contacts::setHeaderData(int section, Qt::Orientation orientation, const QVariant &value, int role)
{
    if (orientation != Qt::Horizontal) {
        return false;
    }
    m_headerData.insert(qMakePair(section, (Qt::ItemDataRole)role), value);
    return true;
}

bool Contacts::setData(const QModelIndex &index, const QVariant &value, int role)
{
    if (index.column() == 0) {
        if (role == Qt::UserRole + 0) {
            if (value.canConvert(qMetaTypeId<bool>())) {
                return setArchive_status(index.row(), value.value<bool>());
            }
        }
        if (role == Qt::UserRole + 1) {
            if (value.canConvert(qMetaTypeId<quint32>())) {
                return setColor(index.row(), value.value<quint32>());
            }
        }
        if (role == Qt::UserRole + 3) {
            if (value.canConvert(qMetaTypeId<bool>())) {
                return setMatched(index.row(), value.value<bool>());
            }
        }
        if (role == Qt::UserRole + 4) {
            if (!value.isValid() || value.isNull() ||value.canConvert(qMetaTypeId<QString>())) {
                return setName(index.row(), value.value<QString>());
            }
        }
        if (role == Qt::UserRole + 5) {
            if (!value.isValid() || value.isNull() ||value.canConvert(qMetaTypeId<QString>())) {
                return setProfile_picture(index.row(), value.value<QString>());
            }
        }
    }
    return false;
}

extern "C" {
    Contacts::Private* contacts_new(Contacts*,
        void (*)(const Contacts*),
        void (*)(Contacts*),
        void (*)(Contacts*),
        void (*)(Contacts*, quintptr, quintptr),
        void (*)(Contacts*),
        void (*)(Contacts*),
        void (*)(Contacts*, int, int),
        void (*)(Contacts*),
        void (*)(Contacts*, int, int, int),
        void (*)(Contacts*),
        void (*)(Contacts*, int, int),
        void (*)(Contacts*));
    void contacts_free(Contacts::Private*);
    bool contacts_add(Contacts::Private*, const ushort*, int);
    void contacts_clear_filter(Contacts::Private*);
    bool contacts_filter(Contacts::Private*, const ushort*, int, bool);
    bool contacts_remove(Contacts::Private*, quint64);
    void contacts_remove_all(Contacts::Private*);
};

extern "C" {
    void messages_data_author(const Messages::Private*, int, QString*, qstring_set);
    void messages_data_body(const Messages::Private*, int, QString*, qstring_set);
    qint64 messages_data_epoch_timestamp_ms(const Messages::Private*, int);
    bool messages_data_error_sending(const Messages::Private*, int);
    qint64 messages_data_message_id(const Messages::Private*, int);
    option_qint64 messages_data_op(const Messages::Private*, int);
    bool messages_data_reached_recipient(const Messages::Private*, int);
    bool messages_data_reached_server(const Messages::Private*, int);
    void messages_data_recipient(const Messages::Private*, int, QString*, qstring_set);
    qint64 messages_data_uuid(const Messages::Private*, int);
    void messages_sort(Messages::Private*, unsigned char column, Qt::SortOrder order = Qt::AscendingOrder);

    int messages_row_count(const Messages::Private*);
    bool messages_insert_rows(Messages::Private*, int, int);
    bool messages_remove_rows(Messages::Private*, int, int);
    bool messages_can_fetch_more(const Messages::Private*);
    void messages_fetch_more(Messages::Private*);
}
int Messages::columnCount(const QModelIndex &parent) const
{
    return (parent.isValid()) ? 0 : 1;
}

bool Messages::hasChildren(const QModelIndex &parent) const
{
    return rowCount(parent) > 0;
}

int Messages::rowCount(const QModelIndex &parent) const
{
    return (parent.isValid()) ? 0 : messages_row_count(m_d);
}

bool Messages::insertRows(int row, int count, const QModelIndex &)
{
    return messages_insert_rows(m_d, row, count);
}

bool Messages::removeRows(int row, int count, const QModelIndex &)
{
    return messages_remove_rows(m_d, row, count);
}

QModelIndex Messages::index(int row, int column, const QModelIndex &parent) const
{
    if (!parent.isValid() && row >= 0 && row < rowCount(parent) && column >= 0 && column < 1) {
        return createIndex(row, column, (quintptr)row);
    }
    return QModelIndex();
}

QModelIndex Messages::parent(const QModelIndex &) const
{
    return QModelIndex();
}

bool Messages::canFetchMore(const QModelIndex &parent) const
{
    return (parent.isValid()) ? 0 : messages_can_fetch_more(m_d);
}

void Messages::fetchMore(const QModelIndex &parent)
{
    if (!parent.isValid()) {
        messages_fetch_more(m_d);
    }
}
void Messages::updatePersistentIndexes() {}

void Messages::sort(int column, Qt::SortOrder order)
{
    messages_sort(m_d, column, order);
}
Qt::ItemFlags Messages::flags(const QModelIndex &i) const
{
    auto flags = QAbstractItemModel::flags(i);
    return flags;
}

QString Messages::author(int row) const
{
    QString s;
    messages_data_author(m_d, row, &s, set_qstring);
    return s;
}

QString Messages::body(int row) const
{
    QString s;
    messages_data_body(m_d, row, &s, set_qstring);
    return s;
}

qint64 Messages::epoch_timestamp_ms(int row) const
{
    return messages_data_epoch_timestamp_ms(m_d, row);
}

bool Messages::error_sending(int row) const
{
    return messages_data_error_sending(m_d, row);
}

qint64 Messages::message_id(int row) const
{
    return messages_data_message_id(m_d, row);
}

QVariant Messages::op(int row) const
{
    QVariant v;
    v = messages_data_op(m_d, row);
    return v;
}

bool Messages::reached_recipient(int row) const
{
    return messages_data_reached_recipient(m_d, row);
}

bool Messages::reached_server(int row) const
{
    return messages_data_reached_server(m_d, row);
}

QString Messages::recipient(int row) const
{
    QString s;
    messages_data_recipient(m_d, row, &s, set_qstring);
    return s;
}

qint64 Messages::uuid(int row) const
{
    return messages_data_uuid(m_d, row);
}

QVariant Messages::data(const QModelIndex &index, int role) const
{
    Q_ASSERT(rowCount(index.parent()) > index.row());
    switch (index.column()) {
    case 0:
        switch (role) {
        case Qt::UserRole + 0:
            return QVariant::fromValue(author(index.row()));
        case Qt::UserRole + 1:
            return QVariant::fromValue(body(index.row()));
        case Qt::UserRole + 2:
            return QVariant::fromValue(epoch_timestamp_ms(index.row()));
        case Qt::UserRole + 3:
            return QVariant::fromValue(error_sending(index.row()));
        case Qt::UserRole + 4:
            return QVariant::fromValue(message_id(index.row()));
        case Qt::UserRole + 5:
            return op(index.row());
        case Qt::UserRole + 6:
            return QVariant::fromValue(reached_recipient(index.row()));
        case Qt::UserRole + 7:
            return QVariant::fromValue(reached_server(index.row()));
        case Qt::UserRole + 8:
            return QVariant::fromValue(recipient(index.row()));
        case Qt::UserRole + 9:
            return QVariant::fromValue(uuid(index.row()));
        }
        break;
    }
    return QVariant();
}

int Messages::role(const char* name) const {
    auto names = roleNames();
    auto i = names.constBegin();
    while (i != names.constEnd()) {
        if (i.value() == name) {
            return i.key();
        }
        ++i;
    }
    return -1;
}
QHash<int, QByteArray> Messages::roleNames() const {
    QHash<int, QByteArray> names = QAbstractItemModel::roleNames();
    names.insert(Qt::UserRole + 0, "author");
    names.insert(Qt::UserRole + 1, "body");
    names.insert(Qt::UserRole + 2, "epoch_timestamp_ms");
    names.insert(Qt::UserRole + 3, "error_sending");
    names.insert(Qt::UserRole + 4, "message_id");
    names.insert(Qt::UserRole + 5, "op");
    names.insert(Qt::UserRole + 6, "reached_recipient");
    names.insert(Qt::UserRole + 7, "reached_server");
    names.insert(Qt::UserRole + 8, "recipient");
    names.insert(Qt::UserRole + 9, "uuid");
    return names;
}
QVariant Messages::headerData(int section, Qt::Orientation orientation, int role) const
{
    if (orientation != Qt::Horizontal) {
        return QVariant();
    }
    return m_headerData.value(qMakePair(section, (Qt::ItemDataRole)role), role == Qt::DisplayRole ?QString::number(section + 1) :QVariant());
}

bool Messages::setHeaderData(int section, Qt::Orientation orientation, const QVariant &value, int role)
{
    if (orientation != Qt::Horizontal) {
        return false;
    }
    m_headerData.insert(qMakePair(section, (Qt::ItemDataRole)role), value);
    return true;
}

extern "C" {
    Messages::Private* messages_new(Messages*, void (*)(Messages*),
        void (*)(const Messages*),
        void (*)(Messages*),
        void (*)(Messages*),
        void (*)(Messages*, quintptr, quintptr),
        void (*)(Messages*),
        void (*)(Messages*),
        void (*)(Messages*, int, int),
        void (*)(Messages*),
        void (*)(Messages*, int, int, int),
        void (*)(Messages*),
        void (*)(Messages*, int, int),
        void (*)(Messages*));
    void messages_free(Messages::Private*);
    void messages_conversation_id_get(const Messages::Private*, QString*, qstring_set);
    void messages_conversation_id_set(Messages::Private*, const ushort *str, int len);
    void messages_conversation_id_set_none(Messages::Private*);
    void messages_clear_conversation_view(Messages::Private*);
    bool messages_delete_conversation(Messages::Private*);
    bool messages_delete_conversation_by_id(Messages::Private*, const ushort*, int);
    bool messages_delete_message(Messages::Private*, quint64);
    bool messages_insert_message(Messages::Private*, const ushort*, int);
    bool messages_reply(Messages::Private*, const ushort*, int, qint64);
};

extern "C" {
    NetworkHandle::Private* network_handle_new(NetworkHandle*, void (*)(NetworkHandle*), void (*)(NetworkHandle*), void (*)(NetworkHandle*));
    void network_handle_free(NetworkHandle::Private*);
    bool network_handle_connection_pending_get(const NetworkHandle::Private*);
    bool network_handle_connection_up_get(const NetworkHandle::Private*);
    bool network_handle_new_message_get(const NetworkHandle::Private*);
    bool network_handle_send_message(const NetworkHandle::Private*, const ushort*, int, const ushort*, int);
};

Config::Config(bool /*owned*/, QObject *parent):
    QObject(parent),
    m_d(nullptr),
    m_ownsPrivate(false)
{
}

Config::Config(QObject *parent):
    QObject(parent),
    m_d(config_new(this,
        configColorChanged,
        configColorschemeChanged,
        configConfigIdChanged,
        configNameChanged,
        configProfile_pictureChanged)),
    m_ownsPrivate(true)
{
}

Config::~Config() {
    if (m_ownsPrivate) {
        config_free(m_d);
    }
}
quint32 Config::color() const
{
    return config_color_get(m_d);
}
void Config::setColor(quint32 v) {
    config_color_set(m_d, v);
}
quint32 Config::colorscheme() const
{
    return config_colorscheme_get(m_d);
}
void Config::setColorscheme(quint32 v) {
    config_colorscheme_set(m_d, v);
}
QString Config::configId() const
{
    QString v;
    config_config_id_get(m_d, &v, set_qstring);
    return v;
}
void Config::setConfigId(const QString& v) {
    config_config_id_set(m_d, reinterpret_cast<const ushort*>(v.data()), v.size());
}
QString Config::name() const
{
    QString v;
    config_name_get(m_d, &v, set_qstring);
    return v;
}
void Config::setName(const QString& v) {
    if (v.isNull()) {
        config_name_set_none(m_d);
    } else {
    config_name_set(m_d, reinterpret_cast<const ushort*>(v.data()), v.size());
    }
}
QString Config::profile_picture() const
{
    QString v;
    config_profile_picture_get(m_d, &v, set_qstring);
    return v;
}
void Config::setProfile_picture(const QString& v) {
    if (v.isNull()) {
        config_profile_picture_set_none(m_d);
    } else {
    config_profile_picture_set(m_d, reinterpret_cast<const ushort*>(v.data()), v.size());
    }
}
bool Config::exists() const
{
    return config_exists(m_d);
}
Contacts::Contacts(bool /*owned*/, QObject *parent):
    QAbstractItemModel(parent),
    m_d(nullptr),
    m_ownsPrivate(false)
{
    initHeaderData();
}

Contacts::Contacts(QObject *parent):
    QAbstractItemModel(parent),
    m_d(contacts_new(this,
        [](const Contacts* o) {
            Q_EMIT o->newDataReady(QModelIndex());
        },
        [](Contacts* o) {
            Q_EMIT o->layoutAboutToBeChanged();
        },
        [](Contacts* o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
        },
        [](Contacts* o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                       o->createIndex(last, 0, last));
        },
        [](Contacts* o) {
            o->beginResetModel();
        },
        [](Contacts* o) {
            o->endResetModel();
        },
        [](Contacts* o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
        },
        [](Contacts* o) {
            o->endInsertRows();
        },
        [](Contacts* o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(), destination);
        },
        [](Contacts* o) {
            o->endMoveRows();
        },
        [](Contacts* o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
        },
        [](Contacts* o) {
            o->endRemoveRows();
        }
)),
    m_ownsPrivate(true)
{
    connect(this, &Contacts::newDataReady, this, [this](const QModelIndex& i) {
        this->fetchMore(i);
    }, Qt::QueuedConnection);
    initHeaderData();
}

Contacts::~Contacts() {
    if (m_ownsPrivate) {
        contacts_free(m_d);
    }
}
void Contacts::initHeaderData() {
}
bool Contacts::add(const QString& id)
{
    return contacts_add(m_d, id.utf16(), id.size());
}
void Contacts::clear_filter()
{
    return contacts_clear_filter(m_d);
}
bool Contacts::filter(const QString& pattern, bool regex)
{
    return contacts_filter(m_d, pattern.utf16(), pattern.size(), regex);
}
bool Contacts::remove(quint64 row_index)
{
    return contacts_remove(m_d, row_index);
}
void Contacts::remove_all()
{
    return contacts_remove_all(m_d);
}
Messages::Messages(bool /*owned*/, QObject *parent):
    QAbstractItemModel(parent),
    m_d(nullptr),
    m_ownsPrivate(false)
{
    initHeaderData();
}

Messages::Messages(QObject *parent):
    QAbstractItemModel(parent),
    m_d(messages_new(this,
        messagesConversationIdChanged,
        [](const Messages* o) {
            Q_EMIT o->newDataReady(QModelIndex());
        },
        [](Messages* o) {
            Q_EMIT o->layoutAboutToBeChanged();
        },
        [](Messages* o) {
            o->updatePersistentIndexes();
            Q_EMIT o->layoutChanged();
        },
        [](Messages* o, quintptr first, quintptr last) {
            o->dataChanged(o->createIndex(first, 0, first),
                       o->createIndex(last, 0, last));
        },
        [](Messages* o) {
            o->beginResetModel();
        },
        [](Messages* o) {
            o->endResetModel();
        },
        [](Messages* o, int first, int last) {
            o->beginInsertRows(QModelIndex(), first, last);
        },
        [](Messages* o) {
            o->endInsertRows();
        },
        [](Messages* o, int first, int last, int destination) {
            o->beginMoveRows(QModelIndex(), first, last, QModelIndex(), destination);
        },
        [](Messages* o) {
            o->endMoveRows();
        },
        [](Messages* o, int first, int last) {
            o->beginRemoveRows(QModelIndex(), first, last);
        },
        [](Messages* o) {
            o->endRemoveRows();
        }
)),
    m_ownsPrivate(true)
{
    connect(this, &Messages::newDataReady, this, [this](const QModelIndex& i) {
        this->fetchMore(i);
    }, Qt::QueuedConnection);
    initHeaderData();
}

Messages::~Messages() {
    if (m_ownsPrivate) {
        messages_free(m_d);
    }
}
void Messages::initHeaderData() {
}
QString Messages::conversationId() const
{
    QString v;
    messages_conversation_id_get(m_d, &v, set_qstring);
    return v;
}
void Messages::setConversationId(const QString& v) {
    if (v.isNull()) {
        messages_conversation_id_set_none(m_d);
    } else {
    messages_conversation_id_set(m_d, reinterpret_cast<const ushort*>(v.data()), v.size());
    }
}
void Messages::clear_conversation_view()
{
    return messages_clear_conversation_view(m_d);
}
bool Messages::delete_conversation()
{
    return messages_delete_conversation(m_d);
}
bool Messages::delete_conversation_by_id(const QString& conversation_id)
{
    return messages_delete_conversation_by_id(m_d, conversation_id.utf16(), conversation_id.size());
}
bool Messages::delete_message(quint64 row_index)
{
    return messages_delete_message(m_d, row_index);
}
bool Messages::insertMessage(const QString& body)
{
    return messages_insert_message(m_d, body.utf16(), body.size());
}
bool Messages::reply(const QString& body, qint64 op)
{
    return messages_reply(m_d, body.utf16(), body.size(), op);
}
NetworkHandle::NetworkHandle(bool /*owned*/, QObject *parent):
    QObject(parent),
    m_d(nullptr),
    m_ownsPrivate(false)
{
}

NetworkHandle::NetworkHandle(QObject *parent):
    QObject(parent),
    m_d(network_handle_new(this,
        networkHandleConnectionPendingChanged,
        networkHandleConnectionUpChanged,
        networkHandleNewMessageChanged)),
    m_ownsPrivate(true)
{
}

NetworkHandle::~NetworkHandle() {
    if (m_ownsPrivate) {
        network_handle_free(m_d);
    }
}
bool NetworkHandle::connectionPending() const
{
    return network_handle_connection_pending_get(m_d);
}
bool NetworkHandle::connectionUp() const
{
    return network_handle_connection_up_get(m_d);
}
bool NetworkHandle::newMessage() const
{
    return network_handle_new_message_get(m_d);
}
bool NetworkHandle::sendMessage(const QString& message_body, const QString& to) const
{
    return network_handle_send_message(m_d, message_body.utf16(), message_body.size(), to.utf16(), to.size());
}
